{"version":3,"file":"curry.mjs","sources":["../../src/curry.ts"],"sourcesContent":["export type Func<TArgs = any, KReturn = any | void> = (\n  ...args: TArgs[]\n) => KReturn\n\nexport const chain =\n  (...funcs: Func[]) =>\n  (...args: any[]) => {\n    return funcs.slice(1).reduce((acc, fn) => fn(acc), funcs[0](...args))\n  }\n\nexport const compose = (...funcs: Func[]) => {\n  return funcs.reverse().reduce((acc, fn) => fn(acc))\n}\n\nexport const partial = (fn: Func, ...args: any[]) => {\n  return (...rest: any[]) => fn(...args, ...rest)\n}\n\n/**\n * Like partial but for unary functions that accept\n * a single object argument\n */\nexport const partob = <T, K, PartialArgs extends Partial<T>>(\n  fn: (args: T) => K,\n  argobj: PartialArgs\n) => {\n  return (restobj: Omit<T, keyof PartialArgs>): K =>\n    fn({\n      ...(argobj as Partial<T>),\n      ...(restobj as Partial<T>)\n    } as T)\n}\n\n/**\n * Creates a Proxy object that will dynamically\n * call the handler argument when attributes are\n * accessed\n */\nexport const proxied = <T, K>(\n  handler: (propertyName: T) => K\n): Record<string, K> => {\n  return new Proxy(\n    {},\n    {\n      get: (target, propertyName: any) => handler(propertyName)\n    }\n  )\n}\n\ntype Cache<T> = Record<string, { exp: number; value: T }>\n\nconst memoize = <T>(\n  cache: Cache<T>,\n  func: Func<any, T>,\n  keyFunc: Func<string> | null,\n  ttl: number\n) => {\n  return function callWithMemo(...args: any): T {\n    const key = keyFunc ? keyFunc(...args) : JSON.stringify({ args })\n    const existing = cache[key]\n    if (existing !== undefined) {\n      if (existing.exp > new Date().getTime()) {\n        return existing.value\n      }\n    }\n    const result = func(...args)\n    cache[key] = {\n      exp: new Date().getTime() + ttl,\n      value: result\n    }\n    return result\n  }\n}\n\n/**\n * Creates a memoized function using the key and ttl\n * options. The returned function will only execute\n * the source function when no value has previously\n * been computed or the previous value has expired\n */\nexport const memo = <TFunc extends Function>(\n  func: TFunc,\n  {\n    key = null,\n    ttl = 300\n  }: {\n    key?: Func<any, string> | null\n    ttl?: number\n  } = {}\n) => {\n  return memoize({}, func as any, key, ttl) as any as TFunc\n}\n\n/**\n * Given a delay and a function returns a new function\n * that will only call the source function after delay\n * milliseconds have passed without any invocations\n */\nexport const debounce = <TArgs extends any[]>(\n  { delay }: { delay: number },\n  func: (...args: TArgs) => any\n): ((...args: TArgs) => void) => {\n  let timer: any = null\n  const debounced = (...args: TArgs) => {\n    clearTimeout(timer)\n    timer = setTimeout(() => func(...args), delay)\n  }\n  return debounced as unknown as (...args: TArgs) => void\n}\n\n/**\n * Given an interval and a function returns a new function\n * that will only call the source function if interval milliseconds\n * have passed since the last invocation\n */\nexport const throttle = <TArgs extends any[]>(\n  { interval }: { interval: number },\n  func: (...args: TArgs) => any\n): ((...args: TArgs) => any) => {\n  let ready = true\n  const throttled = (...args: TArgs) => {\n    if (!ready) return\n    func(...args)\n    ready = false\n    setTimeout(() => {\n      ready = true\n    }, interval)\n  }\n  return throttled as unknown as (...args: TArgs) => any\n}\n\n/**\n * Make an object callable. Given an object and a function\n * the returned object will be a function with all the\n * objects properties.\n *\n * @example\n * ```typescript\n * const car = callable({\n *   wheels: 2\n * }, self => () => {\n *   return 'driving'\n * })\n *\n * car.wheels // => 2\n * car() // => 'driving'\n * ```\n */\nexport const callable = <\n  TValue,\n  TObj extends Record<string | number | symbol, TValue>,\n  TFunc extends Function\n>(\n  obj: TObj,\n  fn: (self: TObj) => TFunc\n): TObj & TFunc => {\n  /* istanbul ignore next */\n  const FUNC = () => {}\n  return new Proxy(Object.assign(FUNC, obj), {\n    get: (target, key: string) => target[key],\n    set: (target, key: string, value: any) => {\n      ;(target as any)[key] = value\n      return true\n    },\n    apply: (target, self, args) => fn(Object.assign({}, target))(...args)\n  }) as unknown as TObj & TFunc\n}\n"],"names":[],"mappings":"AAIO,MAAM,KACX,GAAA,CAAA,GAAI,KACJ,KAAA,CAAA,GAAI,IAAgB,KAAA;AAClB,EAAA,OAAO,KAAM,CAAA,KAAA,CAAM,CAAC,CAAA,CAAE,OAAO,CAAC,GAAA,EAAK,EAAO,KAAA,EAAA,CAAG,GAAG,CAAG,EAAA,KAAA,CAAM,CAAG,CAAA,CAAA,GAAG,IAAI,CAAC,CAAA,CAAA;AACtE,EAAA;AAEW,MAAA,OAAA,GAAU,IAAI,KAAkB,KAAA;AAC3C,EAAO,OAAA,KAAA,CAAM,SAAU,CAAA,MAAA,CAAO,CAAC,GAAK,EAAA,EAAA,KAAO,EAAG,CAAA,GAAG,CAAC,CAAA,CAAA;AACpD,EAAA;AAEa,MAAA,OAAA,GAAU,CAAC,EAAA,EAAA,GAAa,IAAgB,KAAA;AACnD,EAAA,OAAO,IAAI,IAAgB,KAAA,EAAA,CAAG,GAAG,IAAA,EAAM,GAAG,IAAI,CAAA,CAAA;AAChD,EAAA;AAMa,MAAA,MAAA,GAAS,CACpB,EAAA,EACA,MACG,KAAA;AACH,EAAO,OAAA,CAAC,YACN,EAAG,CAAA;AAAA,IACD,GAAI,MAAA;AAAA,IACJ,GAAI,OAAA;AAAA,GACA,CAAA,CAAA;AACV,EAAA;AAOa,MAAA,OAAA,GAAU,CACrB,OACsB,KAAA;AACtB,EAAA,OAAO,IAAI,KAAA;AAAA,IACT,EAAC;AAAA,IACD;AAAA,MACE,GAAK,EAAA,CAAC,MAAQ,EAAA,YAAA,KAAsB,QAAQ,YAAY,CAAA;AAAA,KAC1D;AAAA,GACF,CAAA;AACF,EAAA;AAIA,MAAM,OAAU,GAAA,CACd,KACA,EAAA,IAAA,EACA,SACA,GACG,KAAA;AACH,EAAO,OAAA,SAAS,gBAAgB,IAAc,EAAA;AAC5C,IAAM,MAAA,GAAA,GAAM,OAAU,GAAA,OAAA,CAAQ,GAAG,IAAI,IAAI,IAAK,CAAA,SAAA,CAAU,EAAE,IAAA,EAAM,CAAA,CAAA;AAChE,IAAA,MAAM,WAAW,KAAM,CAAA,GAAA,CAAA,CAAA;AACvB,IAAA,IAAI,aAAa,KAAW,CAAA,EAAA;AAC1B,MAAA,IAAI,SAAS,GAAM,GAAA,IAAI,IAAK,EAAA,CAAE,SAAW,EAAA;AACvC,QAAA,OAAO,QAAS,CAAA,KAAA,CAAA;AAAA,OAClB;AAAA,KACF;AACA,IAAM,MAAA,MAAA,GAAS,IAAK,CAAA,GAAG,IAAI,CAAA,CAAA;AAC3B,IAAA,KAAA,CAAM,GAAO,CAAA,GAAA;AAAA,MACX,GAAK,EAAA,IAAI,IAAK,EAAA,CAAE,SAAY,GAAA,GAAA;AAAA,MAC5B,KAAO,EAAA,MAAA;AAAA,KACT,CAAA;AACA,IAAO,OAAA,MAAA,CAAA;AAAA,GACT,CAAA;AACF,CAAA,CAAA;AAQa,MAAA,IAAA,GAAO,CAClB,IACA,EAAA;AAAA,EACE,GAAM,GAAA,IAAA;AAAA,EACN,GAAM,GAAA,GAAA;AACR,CAAA,GAGI,EACD,KAAA;AACH,EAAA,OAAO,OAAQ,CAAA,EAAI,EAAA,IAAA,EAAa,KAAK,GAAG,CAAA,CAAA;AAC1C,EAAA;AAOO,MAAM,QAAW,GAAA,CACtB,EAAE,KAAA,IACF,IAC+B,KAAA;AAC/B,EAAA,IAAI,KAAa,GAAA,IAAA,CAAA;AACjB,EAAM,MAAA,SAAA,GAAY,IAAI,IAAgB,KAAA;AACpC,IAAA,YAAA,CAAa,KAAK,CAAA,CAAA;AAClB,IAAA,KAAA,GAAQ,WAAW,MAAM,IAAA,CAAK,GAAG,IAAI,GAAG,KAAK,CAAA,CAAA;AAAA,GAC/C,CAAA;AACA,EAAO,OAAA,SAAA,CAAA;AACT,EAAA;AAOO,MAAM,QAAW,GAAA,CACtB,EAAE,QAAA,IACF,IAC8B,KAAA;AAC9B,EAAA,IAAI,KAAQ,GAAA,IAAA,CAAA;AACZ,EAAM,MAAA,SAAA,GAAY,IAAI,IAAgB,KAAA;AACpC,IAAA,IAAI,CAAC,KAAA;AAAO,MAAA,OAAA;AACZ,IAAA,IAAA,CAAK,GAAG,IAAI,CAAA,CAAA;AACZ,IAAQ,KAAA,GAAA,KAAA,CAAA;AACR,IAAA,UAAA,CAAW,MAAM;AACf,MAAQ,KAAA,GAAA,IAAA,CAAA;AAAA,OACP,QAAQ,CAAA,CAAA;AAAA,GACb,CAAA;AACA,EAAO,OAAA,SAAA,CAAA;AACT,EAAA;AAmBa,MAAA,QAAA,GAAW,CAKtB,GAAA,EACA,EACiB,KAAA;AAEjB,EAAA,MAAM,OAAO,MAAM;AAAA,GAAC,CAAA;AACpB,EAAA,OAAO,IAAI,KAAM,CAAA,MAAA,CAAO,MAAO,CAAA,IAAA,EAAM,GAAG,CAAG,EAAA;AAAA,IACzC,GAAK,EAAA,CAAC,MAAQ,EAAA,GAAA,KAAgB,MAAO,CAAA,GAAA,CAAA;AAAA,IACrC,GAAK,EAAA,CAAC,MAAQ,EAAA,GAAA,EAAa,KAAe,KAAA;AACvC,MAAC,OAAe,GAAO,CAAA,GAAA,KAAA,CAAA;AACxB,MAAO,OAAA,IAAA,CAAA;AAAA,KACT;AAAA,IACA,KAAO,EAAA,CAAC,MAAQ,EAAA,IAAA,EAAM,SAAS,EAAG,CAAA,MAAA,CAAO,MAAO,CAAA,EAAI,EAAA,MAAM,CAAC,CAAA,CAAE,GAAG,IAAI,CAAA;AAAA,GACrE,CAAA,CAAA;AACH;;;;"}