{"version":3,"file":"object.mjs","sources":["../../src/object.ts"],"sourcesContent":["import { isFunction, isObject, isPrimitive } from './typed'\n\ntype LowercasedKeys<T extends Record<string, any>> = {\n  [P in keyof T & string as Lowercase<P>]: T[P]\n}\n\ntype UppercasedKeys<T extends Record<string, any>> = {\n  [P in keyof T & string as Uppercase<P>]: T[P]\n}\n\n/**\n * Removes (shakes out) undefined entries from an\n * object. Optional second argument shakes out values\n * by custom evaluation.\n */\nexport const shake = <RemovedKeys extends string, T>(\n  obj: T,\n  filter: (value: any) => boolean = x => x === undefined\n): Omit<T, RemovedKeys> => {\n  if (!obj) return {} as T\n  const keys = Object.keys(obj) as (keyof T)[]\n  return keys.reduce((acc, key) => {\n    if (filter(obj[key])) {\n      return acc\n    } else return { ...acc, [key]: obj[key] }\n  }, {} as T)\n}\n\n/**\n * Map over all the keys of an object to return\n * a new object\n */\nexport const mapKeys = <\n  TValue,\n  TKey extends string | number | symbol,\n  TNewKey extends string | number | symbol\n>(\n  obj: Record<TKey, TValue>,\n  mapFunc: (key: TKey, value: TValue) => TNewKey\n): Record<TNewKey, TValue> => {\n  const keys = Object.keys(obj) as TKey[]\n  return keys.reduce(\n    (acc, key) => ({\n      ...acc,\n      [mapFunc(key as TKey, obj[key])]: obj[key]\n    }),\n    {} as Record<TNewKey, TValue>\n  )\n}\n\n/**\n * Map over all the keys to create a new object\n */\nexport const mapValues = <\n  TValue,\n  TKey extends string | number | symbol,\n  TNewValue\n>(\n  obj: Record<TKey, TValue>,\n  mapFunc: (value: TValue, key: TKey) => TNewValue\n): Record<TKey, TNewValue> => {\n  const keys = Object.keys(obj) as TKey[]\n  return keys.reduce(\n    (acc, key) => ({\n      ...acc,\n      [key]: mapFunc(obj[key], key)\n    }),\n    {} as Record<TKey, TNewValue>\n  )\n}\n\n/**\n * Map over all the keys to create a new object\n */\nexport const mapEntries = <\n  TKey extends string | number | symbol,\n  TValue,\n  TNewKey extends string | number | symbol,\n  TNewValue\n>(\n  obj: Record<TKey, TValue>,\n  toEntry: (key: TKey, value: TValue) => [TNewKey, TNewValue]\n): Record<TNewKey, TNewValue> => {\n  if (!obj) return {} as Record<TNewKey, TNewValue>\n  return Object.entries(obj).reduce((acc, [key, value]) => {\n    const [newKey, newValue] = toEntry(key as TKey, value as TValue)\n    return {\n      ...acc,\n      [newKey]: newValue\n    }\n  }, {} as Record<TNewKey, TNewValue>)\n}\n\n/**\n * Returns an object with { [keys]: value }\n * inverted as { [value]: key }\n */\nexport const invert = <\n  TKey extends string | number | symbol,\n  TValue extends string | number | symbol\n>(\n  obj: Record<TKey, TValue>\n): Record<TValue, TKey> => {\n  if (!obj) return {} as Record<TValue, TKey>\n  const keys = Object.keys(obj) as TKey[]\n  return keys.reduce(\n    (acc, key) => ({\n      ...acc,\n      [obj[key]]: key\n    }),\n    {} as Record<TValue, TKey>\n  )\n}\n\n/**\n * Convert all keys in an object to lower case\n */\nexport const lowerize = <T extends Record<string, any>>(obj: T) =>\n  mapKeys(obj, k => k.toLowerCase()) as LowercasedKeys<T>\n\n/**\n * Convert all keys in an object to upper case\n */\nexport const upperize = <T extends Record<string, any>>(obj: T) =>\n  mapKeys(obj, k => k.toUpperCase()) as UppercasedKeys<T>\n\n/**\n * Creates a shallow copy of the given obejct/value.\n * @param {*} obj value to clone\n * @returns {*} shallow clone of the given value\n */\nexport const clone = <T>(obj: T): T => {\n  // Primitive values do not need cloning.\n  if (isPrimitive(obj)) {\n    return obj\n  }\n\n  // Binding a function to an empty object creates a copy function.\n  if (typeof obj === 'function') {\n    return obj.bind({})\n  }\n\n  // Access the constructor and create a new object. This method can create an array as well.\n  const newObj = new ((obj as Object).constructor as { new (): T })()\n\n  // Assign the props.\n  Object.getOwnPropertyNames(obj).forEach(prop => {\n    // Bypass type checking since the primitive cases are already checked in the beginning\n    ;(newObj as any)[prop] = (obj as any)[prop]\n  })\n\n  return newObj\n}\n\n/**\n * Convert an object to a list, mapping each entry\n * into a list item\n */\nexport const listify = <TValue, TKey extends string | number | symbol, KResult>(\n  obj: Record<TKey, TValue>,\n  toItem: (key: TKey, value: TValue) => KResult\n) => {\n  if (!obj) return []\n  const entries = Object.entries(obj)\n  if (entries.length === 0) return []\n  return entries.reduce((acc, entry) => {\n    return [...acc, toItem(entry[0] as TKey, entry[1] as TValue)]\n  }, [] as KResult[])\n}\n\n/**\n * Pick a list of properties from an object\n * into a new object\n */\nexport const pick = <T extends Record<string, unknown>, TKeys extends keyof T>(\n  obj: T,\n  keys: TKeys[]\n): Pick<T, TKeys> => {\n  if (!obj) return {} as Pick<T, TKeys>\n  return keys.reduce((acc, key) => {\n    if (obj.hasOwnProperty(key)) acc[key] = obj[key]\n    return acc\n  }, {} as Pick<T, TKeys>)\n}\n\n/**\n * Omit a list of properties from an object\n * returning a new object with the properties\n * that remain\n */\nexport const omit = <T, TKeys extends keyof T>(\n  obj: T,\n  keys: TKeys[]\n): Omit<T, TKeys> => {\n  if (!obj) return {} as Omit<T, TKeys>\n  if (!keys || keys.length === 0) return obj as Omit<T, TKeys>\n  return keys.reduce(\n    (acc, key) => {\n      // Gross, I know, it's mutating the object, but we\n      // are allowing it in this very limited scope due\n      // to the performance implications of an omit func.\n      // Not a pattern or practice to use elsewhere.\n      delete acc[key]\n      return acc\n    },\n    { ...obj }\n  )\n}\n\n/**\n * Warning: Passing a function has been @deprecated\n * and will be removed in the next major version.\n */\nexport const get = <T, K>(\n  value: T,\n  funcOrPath: ((t: T) => K) | string,\n  defaultValue: K | null = null\n): K | null => {\n  if (isFunction(funcOrPath)) {\n    try {\n      return (funcOrPath as Function)(value) ?? defaultValue\n    } catch {\n      return defaultValue\n    }\n  }\n  const segments = (funcOrPath as string).split(/[\\.\\[\\]]/g)\n  let current: any = value\n  for (const key of segments) {\n    if (current === null) return defaultValue\n    if (current === undefined) return defaultValue\n    if (key.trim() === '') continue\n    current = current[key]\n  }\n  if (current === undefined) return defaultValue\n  return current\n}\n\n/**\n * Zip two objects together recursivly into a new\n * object applying values from right to left.\n * Recursion only applies to child object properties.\n */\nexport const zip = <X extends Record<string | symbol | number, any>>(\n  a: X,\n  b: X\n): X => {\n  if (!a && !b) return {} as X\n  if (!a) return b as X\n  if (!b) return a as X\n  return Object.entries(a).reduce((acc, [key, value]) => {\n    return {\n      ...acc,\n      [key]: (() => {\n        if (isObject(value)) return zip(value, b[key])\n        return b[key]\n      })()\n    }\n  }, {} as X)\n}\n"],"names":[],"mappings":"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"}