import { isPrimitive, isFunction, isObject } from './typed.mjs';

const shake = (obj, filter = (x) => x === void 0) => {
  if (!obj)
    return {};
  const keys = Object.keys(obj);
  return keys.reduce((acc, key) => {
    if (filter(obj[key])) {
      return acc;
    } else
      return { ...acc, [key]: obj[key] };
  }, {});
};
const mapKeys = (obj, mapFunc) => {
  const keys = Object.keys(obj);
  return keys.reduce(
    (acc, key) => ({
      ...acc,
      [mapFunc(key, obj[key])]: obj[key]
    }),
    {}
  );
};
const mapValues = (obj, mapFunc) => {
  const keys = Object.keys(obj);
  return keys.reduce(
    (acc, key) => ({
      ...acc,
      [key]: mapFunc(obj[key], key)
    }),
    {}
  );
};
const mapEntries = (obj, toEntry) => {
  if (!obj)
    return {};
  return Object.entries(obj).reduce((acc, [key, value]) => {
    const [newKey, newValue] = toEntry(key, value);
    return {
      ...acc,
      [newKey]: newValue
    };
  }, {});
};
const invert = (obj) => {
  if (!obj)
    return {};
  const keys = Object.keys(obj);
  return keys.reduce(
    (acc, key) => ({
      ...acc,
      [obj[key]]: key
    }),
    {}
  );
};
const lowerize = (obj) => mapKeys(obj, (k) => k.toLowerCase());
const upperize = (obj) => mapKeys(obj, (k) => k.toUpperCase());
const clone = (obj) => {
  if (isPrimitive(obj)) {
    return obj;
  }
  if (typeof obj === "function") {
    return obj.bind({});
  }
  const newObj = new obj.constructor();
  Object.getOwnPropertyNames(obj).forEach((prop) => {
    newObj[prop] = obj[prop];
  });
  return newObj;
};
const listify = (obj, toItem) => {
  if (!obj)
    return [];
  const entries = Object.entries(obj);
  if (entries.length === 0)
    return [];
  return entries.reduce((acc, entry) => {
    return [...acc, toItem(entry[0], entry[1])];
  }, []);
};
const pick = (obj, keys) => {
  if (!obj)
    return {};
  return keys.reduce((acc, key) => {
    if (obj.hasOwnProperty(key))
      acc[key] = obj[key];
    return acc;
  }, {});
};
const omit = (obj, keys) => {
  if (!obj)
    return {};
  if (!keys || keys.length === 0)
    return obj;
  return keys.reduce(
    (acc, key) => {
      delete acc[key];
      return acc;
    },
    { ...obj }
  );
};
const get = (value, funcOrPath, defaultValue = null) => {
  if (isFunction(funcOrPath)) {
    try {
      return funcOrPath(value) ?? defaultValue;
    } catch {
      return defaultValue;
    }
  }
  const segments = funcOrPath.split(/[\.\[\]]/g);
  let current = value;
  for (const key of segments) {
    if (current === null)
      return defaultValue;
    if (current === void 0)
      return defaultValue;
    if (key.trim() === "")
      continue;
    current = current[key];
  }
  if (current === void 0)
    return defaultValue;
  return current;
};
const zip = (a, b) => {
  if (!a && !b)
    return {};
  if (!a)
    return b;
  if (!b)
    return a;
  return Object.entries(a).reduce((acc, [key, value]) => {
    return {
      ...acc,
      [key]: (() => {
        if (isObject(value))
          return zip(value, b[key]);
        return b[key];
      })()
    };
  }, {});
};

export { clone, get, invert, listify, lowerize, mapEntries, mapKeys, mapValues, omit, pick, shake, upperize, zip };
//# sourceMappingURL=object.mjs.map
