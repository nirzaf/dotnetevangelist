{"version":3,"file":"array.mjs","sources":["../../src/array.ts"],"sourcesContent":["/**\n * Sorts an array of items into groups. The return value is a map where the keys are\n * the group ids the given getGroupId function produced and the value is an array of\n * each item in that group.\n */\nexport const group = <T, Key extends string | number | symbol>(\n  array: readonly T[],\n  getGroupId: (item: T) => Key\n) => {\n  return array.reduce((acc, item) => {\n    const groupId = getGroupId(item)\n    if (!acc[groupId]) acc[groupId] = []\n    acc[groupId].push(item)\n    return acc\n  }, {} as Record<Key, T[]>)\n}\n\n/**\n * Go through a list of items, starting with the first item,\n * and comparing with the second. Keep the one you want then\n * compare that to the next item in the list with the same\n *\n * Ex. const greatest = () => boil(numbers, (a, b) => a > b)\n */\nexport const boil = <T>(\n  array: readonly T[],\n  compareFunc: (a: T, b: T) => T\n) => {\n  if (!array || (array.length ?? 0) === 0) return null\n  return array.reduce(compareFunc)\n}\n\n/**\n * Sum all numbers in an array. Optionally provide a function\n * to convert objects in the array to number values.\n */\nexport const sum = <T extends number | object>(\n  array: readonly T[],\n  fn?: (item: T) => number\n) => {\n  return (array || []).reduce(\n    (acc, item) => acc + (fn ? fn(item) : (item as number)),\n    0\n  )\n}\n\n/**\n * Get the first item in an array or a default value\n */\nexport const first = <T>(\n  array: readonly T[],\n  defaultValue: T | null | undefined = undefined\n) => {\n  return array?.length > 0 ? array[0] : defaultValue\n}\n\n/**\n * Get the last item in an array or a default value\n */\nexport const last = <T>(\n  array: readonly T[],\n  defaultValue: T | null | undefined = undefined\n) => {\n  return array?.length > 0 ? array[array.length - 1] : defaultValue\n}\n\n/**\n * Sort an array without modifying it and return\n * the newly sorted value\n */\nexport const sort = <T>(\n  array: readonly T[],\n  getter: (item: T) => number,\n  desc = false\n) => {\n  if (!array) return []\n  const asc = (a: T, b: T) => getter(a) - getter(b)\n  const dsc = (a: T, b: T) => getter(b) - getter(a)\n  return array.slice().sort(desc === true ? dsc : asc)\n}\n\n/**\n * Sort an array without modifying it and return\n * the newly sorted value. Allows for a string\n * sorting value.\n */\nexport const alphabetical = <T>(\n  array: readonly T[],\n  getter: (item: T) => string,\n  dir: 'asc' | 'desc' = 'asc'\n) => {\n  if (!array) return []\n  const asc = (a: T, b: T) => `${getter(a)}`.localeCompare(getter(b))\n  const dsc = (a: T, b: T) => `${getter(b)}`.localeCompare(getter(a))\n  return array.slice().sort(dir === 'desc' ? dsc : asc)\n}\n\nexport const counting = <T, TId extends string | number | symbol>(\n  list: readonly T[],\n  identity: (item: T) => TId\n): Record<TId, number> => {\n  return list.reduce((acc, item) => {\n    const id = identity(item)\n    return {\n      ...acc,\n      [id]: (acc[id] ?? 0) + 1\n    }\n  }, {} as Record<TId, number>)\n}\n\n/**\n * Replace an element in an array with a new\n * item without modifying the array and return\n * the new value\n */\nexport const replace = <T>(\n  list: readonly T[],\n  newItem: T,\n  match: (item: T, idx: number) => boolean\n): T[] => {\n  if (!list) return []\n  if (!newItem) return [...list]\n  for (let idx = 0; idx < list.length; idx++) {\n    const item = list[idx]\n    if (match(item, idx)) {\n      return [\n        ...list.slice(0, idx),\n        newItem,\n        ...list.slice(idx + 1, list.length)\n      ]\n    }\n  }\n  return [...list]\n}\n\n/**\n * Convert an array to a dictionary by mapping each item\n * into a dictionary key & value\n */\nexport const objectify = <T, Key extends string | number | symbol, Value = T>(\n  array: readonly T[],\n  getKey: (item: T) => Key,\n  getValue: (item: T) => Value = item => item as unknown as Value\n): Record<Key, Value> => {\n  return array.reduce(\n    (acc, item) => ({\n      ...acc,\n      [getKey(item)]: getValue(item)\n    }),\n    {} as Record<Key, Value>\n  )\n}\n\n/**\n * Select performs a filter and a mapper inside of a reduce,\n * only iterating the list one time.\n *\n * Ex. select([1, 2, 3, 4], x => x*x, x > 2) == [9, 16]\n */\nexport const select = <T, K>(\n  array: readonly T[],\n  mapper: (item: T) => K,\n  condition: (item: T) => boolean\n) => {\n  return array.reduce((acc, item) => {\n    if (!condition(item)) return acc\n    return [...acc, mapper(item)]\n  }, [] as K[])\n}\n\n/**\n * Max gets the greatest value from a list\n *\n * Ex. max([{ num: 1 }, { num: 2 }], x => x.num) == 2\n */\nexport const max = <T extends number | object>(\n  array: readonly T[],\n  getter?: (item: T) => number\n) => {\n  const get = getter ? getter : (v: any) => v\n  return boil(array, (a, b) => (get(a) > get(b) ? a : b))\n}\n\n/**\n * Min gets the smallest value from a list\n *\n * Ex. max([{ num: 1 }, { num: 2 }], x => x.num) == 1\n */\nexport const min = <T extends number | object>(\n  array: readonly T[],\n  getter?: (item: T) => number\n) => {\n  const get = getter ? getter : (v: any) => v\n  return boil(array, (a, b) => (get(a) < get(b) ? a : b))\n}\n\n/**\n * Splits a single list into many lists of the desired size. If\n * given a list of 10 items and a size of 2, it will return 5\n * lists with 2 items each\n */\nexport const cluster = <T>(list: readonly T[], size: number = 2): T[][] => {\n  const clusterCount = Math.ceil(list.length / size)\n  return new Array(clusterCount).fill(null).map((_c: null, i: number) => {\n    return list.slice(i * size, i * size + size)\n  })\n}\n\n/**\n * Given a list of items returns a new list with only\n * unique items. Accepts an optional identity function\n * to convert each item in the list to a comparable identity\n * value\n */\nexport const unique = <T, K extends string | number | symbol>(\n  array: readonly T[],\n  toKey?: (item: T) => K\n): T[] => {\n  const valueMap = array.reduce((acc, item) => {\n    const key = toKey ? toKey(item) : (item as any as string | number | symbol)\n    if (acc[key]) return acc\n    return { ...acc, [key]: item }\n  }, {} as Record<string | number | symbol, T>)\n  return Object.values(valueMap)\n}\n\n/**\n * Creates a generator that will produce an iteration through\n * the range of number as requested.\n *\n * @example for (const i of _.range(3, 3*3, 3)) { console.log(i) }\n */\nexport function* range(\n  start: number,\n  end: number,\n  step: number = 1\n): Generator<number> {\n  for (let i = start; i <= end; i += step) {\n    yield i\n    if (i + step > end) break\n  }\n}\n\n/**\n * Creates a list with numbers ranging from the\n * start to the end by the given step.\n *\n * @example list(0, 3) // [0, 1, 2, 3]\n * @example list(2, 10, 2) // [2, 4, 6, 8 ,10]\n */\nexport const list = (\n  start: number,\n  end: number,\n  step: number = 1\n): number[] => {\n  return Array.from(range(start, end, step))\n}\n\n/**\n * Given an array of arrays, returns a single\n * dimentional array with all items in it.\n */\nexport const flat = <T>(lists: readonly T[][]): T[] => {\n  return lists.reduce((acc, list) => {\n    return [...acc, ...list]\n  }, [])\n}\n\n/**\n * Given two arrays, returns true if any\n * elements intersect\n */\nexport const intersects = <T, K extends string | number | symbol>(\n  listA: readonly T[],\n  listB: readonly T[],\n  identity?: (t: T) => K\n): boolean => {\n  if (!listA || !listB) return false\n  const ident = identity ?? ((x: T) => x as unknown as K)\n  const dictB = listB.reduce(\n    (acc, item) => ({\n      ...acc,\n      [ident(item)]: true\n    }),\n    {} as Record<string | number | symbol, boolean>\n  )\n  return listA.some(value => dictB[ident(value)])\n}\n\n/**\n * Split an array into two array based on\n * a true/false condition function\n */\nexport const fork = <T>(\n  list: readonly T[],\n  condition: (item: T) => boolean\n): [T[], T[]] => {\n  if (!list) return [[], []]\n  return list.reduce(\n    (acc, item) => {\n      const [a, b] = acc\n      if (condition(item)) {\n        return [[...a, item], b]\n      } else {\n        return [a, [...b, item]]\n      }\n    },\n    [[], []] as [T[], T[]]\n  )\n}\n\n/**\n * Given two lists of the same type, iterate the first list\n * and replace items matched by the matcher func in the\n * first place.\n */\nexport const merge = <T>(\n  root: readonly T[],\n  others: readonly T[],\n  matcher: (item: T) => any\n) => {\n  if (!others && !root) return []\n  if (!others) return root\n  if (!root) return []\n  if (!matcher) return root\n  return root.reduce((acc, r) => {\n    const matched = others.find(o => matcher(r) === matcher(o))\n    if (matched) return [...acc, matched]\n    else return [...acc, r]\n  }, [] as T[])\n}\n\n/**\n * Replace an item in an array by a match function condition. If\n * no items match the function condition, appends the new item to\n * the end of the list.\n */\nexport const replaceOrAppend = <T>(\n  list: readonly T[],\n  newItem: T,\n  match: (a: T, idx: number) => boolean\n) => {\n  if (!list && !newItem) return []\n  if (!newItem) return [...list]\n  if (!list) return [newItem]\n  for (let idx = 0; idx < list.length; idx++) {\n    const item = list[idx]\n    if (match(item, idx)) {\n      return [\n        ...list.slice(0, idx),\n        newItem,\n        ...list.slice(idx + 1, list.length)\n      ]\n    }\n  }\n  return [...list, newItem]\n}\n\n/**\n * If the item matching the condition already exists\n * in the list it will be removed. If it does not it\n * will be added.\n */\nexport const toggle = <T>(\n  list: readonly T[],\n  item: T,\n  /**\n   * Converts an item of type T item into a value that\n   * can be checked for equality\n   */\n  toKey?: null | ((item: T, idx: number) => number | string | symbol),\n  options?: {\n    strategy?: 'prepend' | 'append'\n  }\n) => {\n  if (!list && !item) return []\n  if (!list) return [item]\n  if (!item) return [...list]\n  const matcher = toKey\n    ? (x: T, idx: number) => toKey(x, idx) === toKey(item, idx)\n    : (x: T) => x === item\n  const existing = list.find(matcher)\n  if (existing) return list.filter((x, idx) => !matcher(x, idx))\n  const strategy = options?.strategy ?? 'append'\n  if (strategy === 'append') return [...list, item]\n  return [item, ...list]\n}\n\n/**\n * Given a list returns a new list with\n * only truthy values\n */\nexport const sift = <T>(list: readonly T[]): NonNullable<T>[] => {\n  return (list?.filter(x => !!x) as NonNullable<T>[]) ?? []\n}\n\n/**\n * Like a reduce but does not require an array.\n * Only need a number and will iterate the function\n * as many times as specified.\n *\n * NOTE: This is NOT zero indexed. If you pass count=5\n * you will get 1, 2, 3, 4, 5 iteration in the callback\n * function\n */\nexport const iterate = <T>(\n  count: number,\n  func: (currentValue: T, iteration: number) => T,\n  initValue: T\n) => {\n  let value = initValue\n  for (let i = 1; i <= count; i++) {\n    value = func(value, i)\n  }\n  return value\n}\n\n/**\n * Returns all items from the first list that\n * do not exist in the second list.\n */\nexport const diff = <T>(\n  root: readonly T[],\n  other: readonly T[],\n  identity: (item: T) => string | number | symbol = (t: T) =>\n    t as unknown as string | number | symbol\n): T[] => {\n  if (!root?.length && !other?.length) return []\n  if (root?.length === undefined) return [...other]\n  if (!other?.length) return [...root]\n  const bKeys = other.reduce(\n    (acc, item) => ({\n      ...acc,\n      [identity(item)]: true\n    }),\n    {} as Record<string | number | symbol, boolean>\n  )\n  return root.filter(a => !bKeys[identity(a)])\n}\n\n/**\n * Shift array items by n steps\n * If n > 0 items will shift n steps to the right\n * If n < 0 items will shift n steps to the left\n */\nexport function shift<T>(arr: Array<T>, n: number) {\n  if (arr.length === 0) return arr\n\n  const shiftNumber = n % arr.length\n\n  if (shiftNumber === 0) return arr\n\n  return [...arr.slice(-shiftNumber, arr.length), ...arr.slice(0, -shiftNumber)]\n}\n"],"names":["list"],"mappings":"AAKa,MAAA,KAAA,GAAQ,CACnB,KAAA,EACA,UACG,KAAA;AACH,EAAA,OAAO,KAAM,CAAA,MAAA,CAAO,CAAC,GAAA,EAAK,IAAS,KAAA;AACjC,IAAM,MAAA,OAAA,GAAU,WAAW,IAAI,CAAA,CAAA;AAC/B,IAAA,IAAI,CAAC,GAAI,CAAA,OAAA,CAAA;AAAU,MAAA,GAAA,CAAI,WAAW,EAAC,CAAA;AACnC,IAAI,GAAA,CAAA,OAAA,CAAA,CAAS,KAAK,IAAI,CAAA,CAAA;AACtB,IAAO,OAAA,GAAA,CAAA;AAAA,GACT,EAAG,EAAsB,CAAA,CAAA;AAC3B,EAAA;AASa,MAAA,IAAA,GAAO,CAClB,KAAA,EACA,WACG,KAAA;AACH,EAAA,IAAI,CAAC,KAAA,IAAA,CAAU,KAAM,CAAA,MAAA,IAAU,CAAO,MAAA,CAAA;AAAG,IAAO,OAAA,IAAA,CAAA;AAChD,EAAO,OAAA,KAAA,CAAM,OAAO,WAAW,CAAA,CAAA;AACjC,EAAA;AAMa,MAAA,GAAA,GAAM,CACjB,KAAA,EACA,EACG,KAAA;AACH,EAAQ,OAAA,CAAA,KAAA,IAAS,EAAI,EAAA,MAAA;AAAA,IACnB,CAAC,GAAK,EAAA,IAAA,KAAS,OAAO,EAAK,GAAA,EAAA,CAAG,IAAI,CAAK,GAAA,IAAA,CAAA;AAAA,IACvC,CAAA;AAAA,GACF,CAAA;AACF,EAAA;AAKO,MAAM,KAAQ,GAAA,CACnB,KACA,EAAA,YAAA,GAAqC,KAClC,CAAA,KAAA;AACH,EAAA,OAAO,KAAO,EAAA,MAAA,GAAS,CAAI,GAAA,KAAA,CAAM,CAAK,CAAA,GAAA,YAAA,CAAA;AACxC,EAAA;AAKO,MAAM,IAAO,GAAA,CAClB,KACA,EAAA,YAAA,GAAqC,KAClC,CAAA,KAAA;AACH,EAAA,OAAO,OAAO,MAAS,GAAA,CAAA,GAAI,KAAM,CAAA,KAAA,CAAM,SAAS,CAAK,CAAA,GAAA,YAAA,CAAA;AACvD,EAAA;AAMO,MAAM,IAAO,GAAA,CAClB,KACA,EAAA,MAAA,EACA,OAAO,KACJ,KAAA;AACH,EAAA,IAAI,CAAC,KAAA;AAAO,IAAA,OAAO,EAAC,CAAA;AACpB,EAAM,MAAA,GAAA,GAAM,CAAC,CAAM,EAAA,CAAA,KAAS,OAAO,CAAC,CAAA,GAAI,OAAO,CAAC,CAAA,CAAA;AAChD,EAAM,MAAA,GAAA,GAAM,CAAC,CAAM,EAAA,CAAA,KAAS,OAAO,CAAC,CAAA,GAAI,OAAO,CAAC,CAAA,CAAA;AAChD,EAAA,OAAO,MAAM,KAAM,EAAA,CAAE,KAAK,IAAS,KAAA,IAAA,GAAO,MAAM,GAAG,CAAA,CAAA;AACrD,EAAA;AAOO,MAAM,YAAe,GAAA,CAC1B,KACA,EAAA,MAAA,EACA,MAAsB,KACnB,KAAA;AACH,EAAA,IAAI,CAAC,KAAA;AAAO,IAAA,OAAO,EAAC,CAAA;AACpB,EAAM,MAAA,GAAA,GAAM,CAAC,CAAA,EAAM,CAAS,KAAA,CAAA,EAAG,MAAO,CAAA,CAAC,CAAI,CAAA,CAAA,CAAA,aAAA,CAAc,MAAO,CAAA,CAAC,CAAC,CAAA,CAAA;AAClE,EAAM,MAAA,GAAA,GAAM,CAAC,CAAA,EAAM,CAAS,KAAA,CAAA,EAAG,MAAO,CAAA,CAAC,CAAI,CAAA,CAAA,CAAA,aAAA,CAAc,MAAO,CAAA,CAAC,CAAC,CAAA,CAAA;AAClE,EAAA,OAAO,MAAM,KAAM,EAAA,CAAE,KAAK,GAAQ,KAAA,MAAA,GAAS,MAAM,GAAG,CAAA,CAAA;AACtD,EAAA;AAEa,MAAA,QAAA,GAAW,CACtBA,KAAAA,EACA,QACwB,KAAA;AACxB,EAAA,OAAOA,KAAK,CAAA,MAAA,CAAO,CAAC,GAAA,EAAK,IAAS,KAAA;AAChC,IAAM,MAAA,EAAA,GAAK,SAAS,IAAI,CAAA,CAAA;AACxB,IAAO,OAAA;AAAA,MACL,GAAG,GAAA;AAAA,MACH,CAAC,EAAA,GAAA,CAAM,GAAI,CAAA,EAAA,CAAA,IAAO,CAAK,IAAA,CAAA;AAAA,KACzB,CAAA;AAAA,GACF,EAAG,EAAyB,CAAA,CAAA;AAC9B,EAAA;AAOO,MAAM,OAAU,GAAA,CACrBA,KACA,EAAA,OAAA,EACA,KACQ,KAAA;AACR,EAAA,IAAI,CAACA,KAAAA;AAAM,IAAA,OAAO,EAAC,CAAA;AACnB,EAAA,IAAI,CAAC,OAAA;AAAS,IAAO,OAAA,CAAC,GAAGA,KAAI,CAAA,CAAA;AAC7B,EAAA,KAAA,IAAS,GAAM,GAAA,CAAA,EAAG,GAAMA,GAAAA,KAAAA,CAAK,QAAQ,GAAO,EAAA,EAAA;AAC1C,IAAA,MAAM,OAAOA,KAAK,CAAA,GAAA,CAAA,CAAA;AAClB,IAAI,IAAA,KAAA,CAAM,IAAM,EAAA,GAAG,CAAG,EAAA;AACpB,MAAO,OAAA;AAAA,QACL,GAAGA,KAAAA,CAAK,KAAM,CAAA,CAAA,EAAG,GAAG,CAAA;AAAA,QACpB,OAAA;AAAA,QACA,GAAGA,KAAK,CAAA,KAAA,CAAM,GAAM,GAAA,CAAA,EAAGA,MAAK,MAAM,CAAA;AAAA,OACpC,CAAA;AAAA,KACF;AAAA,GACF;AACA,EAAO,OAAA,CAAC,GAAGA,KAAI,CAAA,CAAA;AACjB,EAAA;AAMO,MAAM,YAAY,CACvB,KAAA,EACA,MACA,EAAA,QAAA,GAA+B,UAAQ,IAChB,KAAA;AACvB,EAAA,OAAO,KAAM,CAAA,MAAA;AAAA,IACX,CAAC,KAAK,IAAU,MAAA;AAAA,MACd,GAAG,GAAA;AAAA,MACH,CAAC,MAAA,CAAO,IAAI,CAAA,GAAI,SAAS,IAAI,CAAA;AAAA,KAC/B,CAAA;AAAA,IACA,EAAC;AAAA,GACH,CAAA;AACF,EAAA;AAQO,MAAM,MAAS,GAAA,CACpB,KACA,EAAA,MAAA,EACA,SACG,KAAA;AACH,EAAA,OAAO,KAAM,CAAA,MAAA,CAAO,CAAC,GAAA,EAAK,IAAS,KAAA;AACjC,IAAI,IAAA,CAAC,UAAU,IAAI,CAAA;AAAG,MAAO,OAAA,GAAA,CAAA;AAC7B,IAAA,OAAO,CAAC,GAAG,GAAK,EAAA,MAAA,CAAO,IAAI,CAAC,CAAA,CAAA;AAAA,GAC9B,EAAG,EAAS,CAAA,CAAA;AACd,EAAA;AAOa,MAAA,GAAA,GAAM,CACjB,KAAA,EACA,MACG,KAAA;AACH,EAAA,MAAM,GAAM,GAAA,MAAA,GAAS,MAAS,GAAA,CAAC,CAAW,KAAA,CAAA,CAAA;AAC1C,EAAA,OAAO,IAAK,CAAA,KAAA,EAAO,CAAC,CAAA,EAAG,CAAO,KAAA,GAAA,CAAI,CAAC,CAAA,GAAI,GAAI,CAAA,CAAC,CAAI,GAAA,CAAA,GAAI,CAAE,CAAA,CAAA;AACxD,EAAA;AAOa,MAAA,GAAA,GAAM,CACjB,KAAA,EACA,MACG,KAAA;AACH,EAAA,MAAM,GAAM,GAAA,MAAA,GAAS,MAAS,GAAA,CAAC,CAAW,KAAA,CAAA,CAAA;AAC1C,EAAA,OAAO,IAAK,CAAA,KAAA,EAAO,CAAC,CAAA,EAAG,CAAO,KAAA,GAAA,CAAI,CAAC,CAAA,GAAI,GAAI,CAAA,CAAC,CAAI,GAAA,CAAA,GAAI,CAAE,CAAA,CAAA;AACxD,EAAA;AAOO,MAAM,OAAU,GAAA,CAAIA,KAAoB,EAAA,IAAA,GAAe,CAAa,KAAA;AACzE,EAAA,MAAM,YAAe,GAAA,IAAA,CAAK,IAAKA,CAAAA,KAAAA,CAAK,SAAS,IAAI,CAAA,CAAA;AACjD,EAAO,OAAA,IAAI,KAAM,CAAA,YAAY,CAAE,CAAA,IAAA,CAAK,IAAI,CAAE,CAAA,GAAA,CAAI,CAAC,EAAA,EAAU,CAAc,KAAA;AACrE,IAAA,OAAOA,MAAK,KAAM,CAAA,CAAA,GAAI,IAAM,EAAA,CAAA,GAAI,OAAO,IAAI,CAAA,CAAA;AAAA,GAC5C,CAAA,CAAA;AACH,EAAA;AAQa,MAAA,MAAA,GAAS,CACpB,KAAA,EACA,KACQ,KAAA;AACR,EAAA,MAAM,QAAW,GAAA,KAAA,CAAM,MAAO,CAAA,CAAC,KAAK,IAAS,KAAA;AAC3C,IAAA,MAAM,GAAM,GAAA,KAAA,GAAQ,KAAM,CAAA,IAAI,CAAK,GAAA,IAAA,CAAA;AACnC,IAAA,IAAI,GAAI,CAAA,GAAA,CAAA;AAAM,MAAO,OAAA,GAAA,CAAA;AACrB,IAAA,OAAO,EAAE,GAAG,GAAK,EAAA,CAAC,MAAM,IAAK,EAAA,CAAA;AAAA,GAC/B,EAAG,EAAyC,CAAA,CAAA;AAC5C,EAAO,OAAA,MAAA,CAAO,OAAO,QAAQ,CAAA,CAAA;AAC/B,EAAA;AAQO,UAAU,KACf,CAAA,KAAA,EACA,GACA,EAAA,IAAA,GAAe,CACI,EAAA;AACnB,EAAA,KAAA,IAAS,CAAI,GAAA,KAAA,EAAO,CAAK,IAAA,GAAA,EAAK,KAAK,IAAM,EAAA;AACvC,IAAM,MAAA,CAAA,CAAA;AACN,IAAA,IAAI,IAAI,IAAO,GAAA,GAAA;AAAK,MAAA,MAAA;AAAA,GACtB;AACF,CAAA;AASO,MAAM,IAAO,GAAA,CAClB,KACA,EAAA,GAAA,EACA,OAAe,CACF,KAAA;AACb,EAAA,OAAO,MAAM,IAAK,CAAA,KAAA,CAAM,KAAO,EAAA,GAAA,EAAK,IAAI,CAAC,CAAA,CAAA;AAC3C,EAAA;AAMa,MAAA,IAAA,GAAO,CAAI,KAA+B,KAAA;AACrD,EAAA,OAAO,KAAM,CAAA,MAAA,CAAO,CAAC,GAAA,EAAKA,KAAS,KAAA;AACjC,IAAA,OAAO,CAAC,GAAG,GAAK,EAAA,GAAGA,KAAI,CAAA,CAAA;AAAA,GACzB,EAAG,EAAE,CAAA,CAAA;AACP,EAAA;AAMO,MAAM,UAAa,GAAA,CACxB,KACA,EAAA,KAAA,EACA,QACY,KAAA;AACZ,EAAI,IAAA,CAAC,SAAS,CAAC,KAAA;AAAO,IAAO,OAAA,KAAA,CAAA;AAC7B,EAAM,MAAA,KAAA,GAAQ,QAAa,KAAA,CAAC,CAAS,KAAA,CAAA,CAAA,CAAA;AACrC,EAAA,MAAM,QAAQ,KAAM,CAAA,MAAA;AAAA,IAClB,CAAC,KAAK,IAAU,MAAA;AAAA,MACd,GAAG,GAAA;AAAA,MACH,CAAC,KAAM,CAAA,IAAI,CAAI,GAAA,IAAA;AAAA,KACjB,CAAA;AAAA,IACA,EAAC;AAAA,GACH,CAAA;AACA,EAAA,OAAO,MAAM,IAAK,CAAA,CAAA,KAAA,KAAS,KAAM,CAAA,KAAA,CAAM,KAAK,CAAE,CAAA,CAAA,CAAA;AAChD,EAAA;AAMa,MAAA,IAAA,GAAO,CAClBA,KAAAA,EACA,SACe,KAAA;AACf,EAAA,IAAI,CAACA,KAAAA;AAAM,IAAA,OAAO,CAAC,EAAI,EAAA,EAAE,CAAA,CAAA;AACzB,EAAA,OAAOA,KAAK,CAAA,MAAA;AAAA,IACV,CAAC,KAAK,IAAS,KAAA;AACb,MAAM,MAAA,CAAC,CAAG,EAAA,CAAC,CAAI,GAAA,GAAA,CAAA;AACf,MAAI,IAAA,SAAA,CAAU,IAAI,CAAG,EAAA;AACnB,QAAA,OAAO,CAAC,CAAC,GAAG,CAAG,EAAA,IAAI,GAAG,CAAC,CAAA,CAAA;AAAA,OAClB,MAAA;AACL,QAAA,OAAO,CAAC,CAAG,EAAA,CAAC,GAAG,CAAA,EAAG,IAAI,CAAC,CAAA,CAAA;AAAA,OACzB;AAAA,KACF;AAAA,IACA,CAAC,EAAI,EAAA,EAAE,CAAA;AAAA,GACT,CAAA;AACF,EAAA;AAOO,MAAM,KAAQ,GAAA,CACnB,IACA,EAAA,MAAA,EACA,OACG,KAAA;AACH,EAAI,IAAA,CAAC,UAAU,CAAC,IAAA;AAAM,IAAA,OAAO,EAAC,CAAA;AAC9B,EAAA,IAAI,CAAC,MAAA;AAAQ,IAAO,OAAA,IAAA,CAAA;AACpB,EAAA,IAAI,CAAC,IAAA;AAAM,IAAA,OAAO,EAAC,CAAA;AACnB,EAAA,IAAI,CAAC,OAAA;AAAS,IAAO,OAAA,IAAA,CAAA;AACrB,EAAA,OAAO,IAAK,CAAA,MAAA,CAAO,CAAC,GAAA,EAAK,CAAM,KAAA;AAC7B,IAAM,MAAA,OAAA,GAAU,OAAO,IAAK,CAAA,CAAA,CAAA,KAAK,QAAQ,CAAC,CAAA,KAAM,OAAQ,CAAA,CAAC,CAAC,CAAA,CAAA;AAC1D,IAAI,IAAA,OAAA;AAAS,MAAO,OAAA,CAAC,GAAG,GAAA,EAAK,OAAO,CAAA,CAAA;AAAA;AAC/B,MAAO,OAAA,CAAC,GAAG,GAAA,EAAK,CAAC,CAAA,CAAA;AAAA,GACxB,EAAG,EAAS,CAAA,CAAA;AACd,EAAA;AAOO,MAAM,eAAkB,GAAA,CAC7BA,KACA,EAAA,OAAA,EACA,KACG,KAAA;AACH,EAAI,IAAA,CAACA,SAAQ,CAAC,OAAA;AAAS,IAAA,OAAO,EAAC,CAAA;AAC/B,EAAA,IAAI,CAAC,OAAA;AAAS,IAAO,OAAA,CAAC,GAAGA,KAAI,CAAA,CAAA;AAC7B,EAAA,IAAI,CAACA,KAAAA;AAAM,IAAA,OAAO,CAAC,OAAO,CAAA,CAAA;AAC1B,EAAA,KAAA,IAAS,GAAM,GAAA,CAAA,EAAG,GAAMA,GAAAA,KAAAA,CAAK,QAAQ,GAAO,EAAA,EAAA;AAC1C,IAAA,MAAM,OAAOA,KAAK,CAAA,GAAA,CAAA,CAAA;AAClB,IAAI,IAAA,KAAA,CAAM,IAAM,EAAA,GAAG,CAAG,EAAA;AACpB,MAAO,OAAA;AAAA,QACL,GAAGA,KAAAA,CAAK,KAAM,CAAA,CAAA,EAAG,GAAG,CAAA;AAAA,QACpB,OAAA;AAAA,QACA,GAAGA,KAAK,CAAA,KAAA,CAAM,GAAM,GAAA,CAAA,EAAGA,MAAK,MAAM,CAAA;AAAA,OACpC,CAAA;AAAA,KACF;AAAA,GACF;AACA,EAAO,OAAA,CAAC,GAAGA,KAAAA,EAAM,OAAO,CAAA,CAAA;AAC1B,EAAA;AAOO,MAAM,MAAS,GAAA,CACpBA,KACA,EAAA,IAAA,EAKA,OACA,OAGG,KAAA;AACH,EAAI,IAAA,CAACA,SAAQ,CAAC,IAAA;AAAM,IAAA,OAAO,EAAC,CAAA;AAC5B,EAAA,IAAI,CAACA,KAAAA;AAAM,IAAA,OAAO,CAAC,IAAI,CAAA,CAAA;AACvB,EAAA,IAAI,CAAC,IAAA;AAAM,IAAO,OAAA,CAAC,GAAGA,KAAI,CAAA,CAAA;AAC1B,EAAA,MAAM,OAAU,GAAA,KAAA,GACZ,CAAC,CAAA,EAAM,QAAgB,KAAM,CAAA,CAAA,EAAG,GAAG,CAAA,KAAM,MAAM,IAAM,EAAA,GAAG,CACxD,GAAA,CAAC,MAAS,CAAM,KAAA,IAAA,CAAA;AACpB,EAAM,MAAA,QAAA,GAAWA,KAAK,CAAA,IAAA,CAAK,OAAO,CAAA,CAAA;AAClC,EAAI,IAAA,QAAA;AAAU,IAAOA,OAAAA,KAAAA,CAAK,OAAO,CAAC,CAAA,EAAG,QAAQ,CAAC,OAAA,CAAQ,CAAG,EAAA,GAAG,CAAC,CAAA,CAAA;AAC7D,EAAM,MAAA,QAAA,GAAW,SAAS,QAAY,IAAA,QAAA,CAAA;AACtC,EAAA,IAAI,QAAa,KAAA,QAAA;AAAU,IAAO,OAAA,CAAC,GAAGA,KAAAA,EAAM,IAAI,CAAA,CAAA;AAChD,EAAO,OAAA,CAAC,IAAM,EAAA,GAAGA,KAAI,CAAA,CAAA;AACvB,EAAA;AAMa,MAAA,IAAA,GAAO,CAAIA,KAAyC,KAAA;AAC/D,EAAA,OAAQA,OAAM,MAAO,CAAA,CAAA,CAAA,KAAK,CAAC,CAAC,CAAC,KAA0B,EAAC,CAAA;AAC1D,EAAA;AAWO,MAAM,OAAU,GAAA,CACrB,KACA,EAAA,IAAA,EACA,SACG,KAAA;AACH,EAAA,IAAI,KAAQ,GAAA,SAAA,CAAA;AACZ,EAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAK,IAAA,KAAA,EAAO,CAAK,EAAA,EAAA;AAC/B,IAAQ,KAAA,GAAA,IAAA,CAAK,OAAO,CAAC,CAAA,CAAA;AAAA,GACvB;AACA,EAAO,OAAA,KAAA,CAAA;AACT,EAAA;AAMO,MAAM,OAAO,CAClB,IAAA,EACA,OACA,QAAkD,GAAA,CAAC,MACjD,CACM,KAAA;AACR,EAAA,IAAI,CAAC,IAAA,EAAM,MAAU,IAAA,CAAC,KAAO,EAAA,MAAA;AAAQ,IAAA,OAAO,EAAC,CAAA;AAC7C,EAAA,IAAI,MAAM,MAAW,KAAA,KAAA,CAAA;AAAW,IAAO,OAAA,CAAC,GAAG,KAAK,CAAA,CAAA;AAChD,EAAA,IAAI,CAAC,KAAO,EAAA,MAAA;AAAQ,IAAO,OAAA,CAAC,GAAG,IAAI,CAAA,CAAA;AACnC,EAAA,MAAM,QAAQ,KAAM,CAAA,MAAA;AAAA,IAClB,CAAC,KAAK,IAAU,MAAA;AAAA,MACd,GAAG,GAAA;AAAA,MACH,CAAC,QAAS,CAAA,IAAI,CAAI,GAAA,IAAA;AAAA,KACpB,CAAA;AAAA,IACA,EAAC;AAAA,GACH,CAAA;AACA,EAAA,OAAO,KAAK,MAAO,CAAA,CAAA,CAAA,KAAK,CAAC,KAAM,CAAA,QAAA,CAAS,CAAC,CAAE,CAAA,CAAA,CAAA;AAC7C,EAAA;AAOgB,SAAA,KAAA,CAAS,KAAe,CAAW,EAAA;AACjD,EAAA,IAAI,IAAI,MAAW,KAAA,CAAA;AAAG,IAAO,OAAA,GAAA,CAAA;AAE7B,EAAM,MAAA,WAAA,GAAc,IAAI,GAAI,CAAA,MAAA,CAAA;AAE5B,EAAA,IAAI,WAAgB,KAAA,CAAA;AAAG,IAAO,OAAA,GAAA,CAAA;AAE9B,EAAA,OAAO,CAAC,GAAG,GAAI,CAAA,KAAA,CAAM,CAAC,WAAa,EAAA,GAAA,CAAI,MAAM,CAAA,EAAG,GAAG,GAAI,CAAA,KAAA,CAAM,CAAG,EAAA,CAAC,WAAW,CAAC,CAAA,CAAA;AAC/E;;;;"}