/**
 * Sorts an array of items into groups. The return value is a map where the keys are
 * the group ids the given getGroupId function produced and the value is an array of
 * each item in that group.
 */
declare const group: <T, Key extends string | number | symbol>(array: readonly T[], getGroupId: (item: T) => Key) => Record<Key, T[]>;
/**
 * Go through a list of items, starting with the first item,
 * and comparing with the second. Keep the one you want then
 * compare that to the next item in the list with the same
 *
 * Ex. const greatest = () => boil(numbers, (a, b) => a > b)
 */
declare const boil: <T>(array: readonly T[], compareFunc: (a: T, b: T) => T) => T | null;
/**
 * Sum all numbers in an array. Optionally provide a function
 * to convert objects in the array to number values.
 */
declare const sum: <T extends number | object>(array: readonly T[], fn?: ((item: T) => number) | undefined) => number;
/**
 * Get the first item in an array or a default value
 */
declare const first: <T>(array: readonly T[], defaultValue?: T | null | undefined) => T | null | undefined;
/**
 * Get the last item in an array or a default value
 */
declare const last: <T>(array: readonly T[], defaultValue?: T | null | undefined) => T | null | undefined;
/**
 * Sort an array without modifying it and return
 * the newly sorted value
 */
declare const sort: <T>(array: readonly T[], getter: (item: T) => number, desc?: boolean) => T[];
/**
 * Sort an array without modifying it and return
 * the newly sorted value. Allows for a string
 * sorting value.
 */
declare const alphabetical: <T>(array: readonly T[], getter: (item: T) => string, dir?: 'asc' | 'desc') => T[];
declare const counting: <T, TId extends string | number | symbol>(list: readonly T[], identity: (item: T) => TId) => Record<TId, number>;
/**
 * Replace an element in an array with a new
 * item without modifying the array and return
 * the new value
 */
declare const replace: <T>(list: readonly T[], newItem: T, match: (item: T, idx: number) => boolean) => T[];
/**
 * Convert an array to a dictionary by mapping each item
 * into a dictionary key & value
 */
declare const objectify: <T, Key extends string | number | symbol, Value = T>(array: readonly T[], getKey: (item: T) => Key, getValue?: (item: T) => Value) => Record<Key, Value>;
/**
 * Select performs a filter and a mapper inside of a reduce,
 * only iterating the list one time.
 *
 * Ex. select([1, 2, 3, 4], x => x*x, x > 2) == [9, 16]
 */
declare const select: <T, K>(array: readonly T[], mapper: (item: T) => K, condition: (item: T) => boolean) => K[];
/**
 * Max gets the greatest value from a list
 *
 * Ex. max([{ num: 1 }, { num: 2 }], x => x.num) == 2
 */
declare const max: <T extends number | object>(array: readonly T[], getter?: ((item: T) => number) | undefined) => T | null;
/**
 * Min gets the smallest value from a list
 *
 * Ex. max([{ num: 1 }, { num: 2 }], x => x.num) == 1
 */
declare const min: <T extends number | object>(array: readonly T[], getter?: ((item: T) => number) | undefined) => T | null;
/**
 * Splits a single list into many lists of the desired size. If
 * given a list of 10 items and a size of 2, it will return 5
 * lists with 2 items each
 */
declare const cluster: <T>(list: readonly T[], size?: number) => T[][];
/**
 * Given a list of items returns a new list with only
 * unique items. Accepts an optional identity function
 * to convert each item in the list to a comparable identity
 * value
 */
declare const unique: <T, K extends string | number | symbol>(array: readonly T[], toKey?: ((item: T) => K) | undefined) => T[];
/**
 * Creates a generator that will produce an iteration through
 * the range of number as requested.
 *
 * @example for (const i of _.range(3, 3*3, 3)) { console.log(i) }
 */
declare function range(start: number, end: number, step?: number): Generator<number>;
/**
 * Creates a list with numbers ranging from the
 * start to the end by the given step.
 *
 * @example list(0, 3) // [0, 1, 2, 3]
 * @example list(2, 10, 2) // [2, 4, 6, 8 ,10]
 */
declare const list: (start: number, end: number, step?: number) => number[];
/**
 * Given an array of arrays, returns a single
 * dimentional array with all items in it.
 */
declare const flat: <T>(lists: readonly T[][]) => T[];
/**
 * Given two arrays, returns true if any
 * elements intersect
 */
declare const intersects: <T, K extends string | number | symbol>(listA: readonly T[], listB: readonly T[], identity?: ((t: T) => K) | undefined) => boolean;
/**
 * Split an array into two array based on
 * a true/false condition function
 */
declare const fork: <T>(list: readonly T[], condition: (item: T) => boolean) => [T[], T[]];
/**
 * Given two lists of the same type, iterate the first list
 * and replace items matched by the matcher func in the
 * first place.
 */
declare const merge: <T>(root: readonly T[], others: readonly T[], matcher: (item: T) => any) => readonly T[];
/**
 * Replace an item in an array by a match function condition. If
 * no items match the function condition, appends the new item to
 * the end of the list.
 */
declare const replaceOrAppend: <T>(list: readonly T[], newItem: T, match: (a: T, idx: number) => boolean) => T[];
/**
 * If the item matching the condition already exists
 * in the list it will be removed. If it does not it
 * will be added.
 */
declare const toggle: <T>(list: readonly T[], item: T, toKey?: ((item: T, idx: number) => number | string | symbol) | null | undefined, options?: {
    strategy?: 'prepend' | 'append';
}) => T[];
/**
 * Given a list returns a new list with
 * only truthy values
 */
declare const sift: <T>(list: readonly T[]) => NonNullable<T>[];
/**
 * Like a reduce but does not require an array.
 * Only need a number and will iterate the function
 * as many times as specified.
 *
 * NOTE: This is NOT zero indexed. If you pass count=5
 * you will get 1, 2, 3, 4, 5 iteration in the callback
 * function
 */
declare const iterate: <T>(count: number, func: (currentValue: T, iteration: number) => T, initValue: T) => T;
/**
 * Returns all items from the first list that
 * do not exist in the second list.
 */
declare const diff: <T>(root: readonly T[], other: readonly T[], identity?: (item: T) => string | number | symbol) => T[];
/**
 * Shift array items by n steps
 * If n > 0 items will shift n steps to the right
 * If n < 0 items will shift n steps to the left
 */
declare function shift<T>(arr: Array<T>, n: number): T[];

/**
 * An async reduce function. Works like the
 * built-in Array.reduce function but handles
 * an async reducer function
 */
declare const reduce: <T, K>(array: readonly T[], asyncReducer: (acc: K, item: T) => Promise<K>, initValue?: K | undefined) => Promise<K>;
/**
 * An async map function. Works like the
 * built-in Array.map function but handles
 * an async mapper function
 */
declare const map: <T, K>(array: readonly T[], asyncMapFunc: (item: T, index: number) => Promise<K>) => Promise<K[]>;
/**
 * Useful when for script like things where cleanup
 * should be done on fail or sucess no matter.
 *
 * You can call defer many times to register many
 * defered functions that will all be called when
 * the function exits in any state.
 */
declare const defer: <TResponse>(func: (register: (fn: (error?: any) => any, options?: {
    rethrow?: boolean;
}) => void) => Promise<TResponse>) => Promise<TResponse>;
/**
 * Support for the built-in AggregateError
 * is still new. Node < 15 doesn't have it
 * so patching here.
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AggregateError#browser_compatibility
 */
declare class AggregateError extends Error {
    errors: Error[];
    constructor(errors?: Error[]);
}
/**
 * Executes many async functions in parallel. Returns the
 * results from all functions as an array. After all functions
 * have resolved, if any errors were thrown, they are rethrown
 * in an instance of AggregateError
 */
declare const parallel: <T, K>(limit: number, array: readonly T[], func: (item: T) => Promise<K>) => Promise<K[]>;
/**
 * Retries the given function the specified number
 * of times.
 */
declare const retry: <TResponse>(options: {
    times?: number | undefined;
    delay?: number | null | undefined;
    backoff?: ((count: number) => number) | undefined;
}, func: (exit: (err: any) => void) => Promise<TResponse>) => Promise<TResponse>;
/**
 * Async wait
 */
declare const sleep: (milliseconds: number) => Promise<unknown>;
type ArgumentsType<T> = T extends (...args: infer U) => any ? U : never;
type UnwrapPromisify<T> = T extends Promise<infer U> ? U : T;
/**
 * A helper to try an async function without forking
 * the control flow. Returns an error first callback _like_
 * array response as [Error, result]
 */
declare const tryit: <TFunction extends (...args: any) => any>(func: TFunction) => (...args: ArgumentsType<TFunction>) => Promise<[Error, null] | [null, UnwrapPromisify<ReturnType<TFunction>>]>;

type Func<TArgs = any, KReturn = any | void> = (...args: TArgs[]) => KReturn;
declare const chain: (...funcs: Func[]) => (...args: any[]) => any;
declare const compose: (...funcs: Func[]) => Func<any, any>;
declare const partial: (fn: Func, ...args: any[]) => (...rest: any[]) => any;
/**
 * Like partial but for unary functions that accept
 * a single object argument
 */
declare const partob: <T, K, PartialArgs extends Partial<T>>(fn: (args: T) => K, argobj: PartialArgs) => (restobj: Omit<T, keyof PartialArgs>) => K;
/**
 * Creates a Proxy object that will dynamically
 * call the handler argument when attributes are
 * accessed
 */
declare const proxied: <T, K>(handler: (propertyName: T) => K) => Record<string, K>;
/**
 * Creates a memoized function using the key and ttl
 * options. The returned function will only execute
 * the source function when no value has previously
 * been computed or the previous value has expired
 */
declare const memo: <TFunc extends Function>(func: TFunc, { key, ttl }?: {
    key?: Func<any, string> | null | undefined;
    ttl?: number | undefined;
}) => TFunc;
/**
 * Given a delay and a function returns a new function
 * that will only call the source function after delay
 * milliseconds have passed without any invocations
 */
declare const debounce: <TArgs extends any[]>({ delay }: {
    delay: number;
}, func: (...args: TArgs) => any) => (...args: TArgs) => void;
/**
 * Given an interval and a function returns a new function
 * that will only call the source function if interval milliseconds
 * have passed since the last invocation
 */
declare const throttle: <TArgs extends any[]>({ interval }: {
    interval: number;
}, func: (...args: TArgs) => any) => (...args: TArgs) => any;
/**
 * Make an object callable. Given an object and a function
 * the returned object will be a function with all the
 * objects properties.
 *
 * @example
 * ```typescript
 * const car = callable({
 *   wheels: 2
 * }, self => () => {
 *   return 'driving'
 * })
 *
 * car.wheels // => 2
 * car() // => 'driving'
 * ```
 */
declare const callable: <TValue, TObj extends Record<string | number | symbol, TValue>, TFunc extends Function>(obj: TObj, fn: (self: TObj) => TFunc) => TObj & TFunc;

declare const toFloat: <T extends number | null = number>(value: any, defaultValue?: T | undefined) => number | T;
declare const toInt: <T extends number | null = number>(value: any, defaultValue?: T | undefined) => number | T;

type LowercasedKeys<T extends Record<string, any>> = {
    [P in keyof T & string as Lowercase<P>]: T[P];
};
type UppercasedKeys<T extends Record<string, any>> = {
    [P in keyof T & string as Uppercase<P>]: T[P];
};
/**
 * Removes (shakes out) undefined entries from an
 * object. Optional second argument shakes out values
 * by custom evaluation.
 */
declare const shake: <RemovedKeys extends string, T>(obj: T, filter?: (value: any) => boolean) => Omit<T, RemovedKeys>;
/**
 * Map over all the keys of an object to return
 * a new object
 */
declare const mapKeys: <TValue, TKey extends string | number | symbol, TNewKey extends string | number | symbol>(obj: Record<TKey, TValue>, mapFunc: (key: TKey, value: TValue) => TNewKey) => Record<TNewKey, TValue>;
/**
 * Map over all the keys to create a new object
 */
declare const mapValues: <TValue, TKey extends string | number | symbol, TNewValue>(obj: Record<TKey, TValue>, mapFunc: (value: TValue, key: TKey) => TNewValue) => Record<TKey, TNewValue>;
/**
 * Map over all the keys to create a new object
 */
declare const mapEntries: <TKey extends string | number | symbol, TValue, TNewKey extends string | number | symbol, TNewValue>(obj: Record<TKey, TValue>, toEntry: (key: TKey, value: TValue) => [TNewKey, TNewValue]) => Record<TNewKey, TNewValue>;
/**
 * Returns an object with { [keys]: value }
 * inverted as { [value]: key }
 */
declare const invert: <TKey extends string | number | symbol, TValue extends string | number | symbol>(obj: Record<TKey, TValue>) => Record<TValue, TKey>;
/**
 * Convert all keys in an object to lower case
 */
declare const lowerize: <T extends Record<string, any>>(obj: T) => LowercasedKeys<T>;
/**
 * Convert all keys in an object to upper case
 */
declare const upperize: <T extends Record<string, any>>(obj: T) => UppercasedKeys<T>;
/**
 * Creates a shallow copy of the given obejct/value.
 * @param {*} obj value to clone
 * @returns {*} shallow clone of the given value
 */
declare const clone: <T>(obj: T) => T;
/**
 * Convert an object to a list, mapping each entry
 * into a list item
 */
declare const listify: <TValue, TKey extends string | number | symbol, KResult>(obj: Record<TKey, TValue>, toItem: (key: TKey, value: TValue) => KResult) => KResult[];
/**
 * Pick a list of properties from an object
 * into a new object
 */
declare const pick: <T extends Record<string, unknown>, TKeys extends keyof T>(obj: T, keys: TKeys[]) => Pick<T, TKeys>;
/**
 * Omit a list of properties from an object
 * returning a new object with the properties
 * that remain
 */
declare const omit: <T, TKeys extends keyof T>(obj: T, keys: TKeys[]) => Omit<T, TKeys>;
/**
 * Warning: Passing a function has been @deprecated
 * and will be removed in the next major version.
 */
declare const get: <T, K>(value: T, funcOrPath: string | ((t: T) => K), defaultValue?: K | null) => K | null;
/**
 * Zip two objects together recursivly into a new
 * object applying values from right to left.
 * Recursion only applies to child object properties.
 */
declare const zip: <X extends Record<string | number | symbol, any>>(a: X, b: X) => X;

/**
 * Generates a random number between min and max
 */
declare const random: (min: number, max: number) => number;
/**
 * Draw a random item from a list. Returns
 * null if the list is empty
 */
declare const draw: <T>(array: readonly T[]) => T | null;
declare const shuffle: <T>(array: readonly T[]) => T[];
declare const uid: (length: number, specials?: string) => string;

/**
 * Creates a series object around a list of values
 * that should be treated with order.
 */
declare const series: <T extends string | symbol>(...items: T[]) => {
    /**
     * Given two values in the series, returns the
     * value that occurs later in the series
     */
    min: (a: T, b: T) => T;
    /**
     * Given two values in the series, returns the
     * value that occurs earlier in the series
     */
    max: (a: T, b: T) => T;
    /**
     * Returns the first item from the series
     */
    first: () => T;
    /**
     * Returns the last item in the series
     */
    last: () => T;
    /**
     * Given an item in the series returns the next item
     * in the series or default if the given value is
     * the last item in the series
     */
    next: <TDefault extends T | null>(current: T, defaultValue?: TDefault | undefined) => T | TDefault;
    /**
     * Given an item in the series returns the previous item
     * in the series or default if the given value is
     * the first item in the series
     */
    previous: <TDefault_1 extends T | null>(current: T, defaultValue?: TDefault_1 | undefined) => T | TDefault_1;
};

/**
 * Capitalize the first word of the string
 *
 * capitalize('hello')   -> 'Hello'
 * capitalize('va va voom') -> 'Va va voom'
 */
declare const capitalize: (str: string) => string;
/**
 * Formats the given string in camel case fashion
 *
 * camel('hello world')   -> 'helloWorld'
 * camel('va va-VOOM') -> 'vaVaVoom'
 * camel('helloWorld') -> 'helloWorld'
 */
declare const camel: (str: string) => string;
/**
 * Formats the given string in snake case fashion
 *
 * snake('hello world')   -> 'hello_world'
 * snake('va va-VOOM') -> 'va_va_voom'
 * snake('helloWord') -> 'hello_world'
 */
declare const snake: (str: string) => string;
/**
 * Formats the given string in dash case fashion
 *
 * dash('hello world')   -> 'hello-world'
 * dash('va va_VOOM') -> 'va-va-voom'
 * dash('helloWord') -> 'hello-word'
 */
declare const dash: (str: string) => string;
/**
 * Formats the given string in pascal case fashion
 *
 * pascal('hello world') -> 'HelloWorld'
 * pascal('va va boom') -> 'VaVaBoom'
 */
declare const pascal: (str: string) => string;
/**
 * Formats the given string in title case fashion
 *
 * title('hello world') -> 'Hello World'
 * title('va_va_boom') -> 'Va Va Boom'
 * title('root-hook') -> 'Root Hook'
 * title('queryItems') -> 'Query Items'
 */
declare const title: (str: string | null | undefined) => string;
/**
 * template is used to replace data by name in template strings.
 * The default expression looks for {{name}} to identify names.
 *
 * Ex. template('Hello, {{name}}', { name: 'ray' })
 * Ex. template('Hello, <name>', { name: 'ray' }, /<(.+?)>/g)
 */
declare const template: (str: string, data: Record<string, any>, regex?: RegExp) => string;
/**
 * Trims all prefix and suffix characters from the given
 * string. Like the builtin trim function but accepts
 * other characters you would like to trim.
 *
 * ```typescript
 * trim('  hello ') // => 'hello'
 * trim('__hello__', '_') // => 'hello'
 * trim('/repos/:owner/:repo/', '/') // => 'repos/:owner/:repo'
 * ```
 */
declare const trim: (str: string | null | undefined, charsToTrim?: string) => string;

declare const isSymbol: (value: any) => value is symbol;
declare const isArray: (value: any) => value is unknown[];
declare const isObject: (value: any) => value is object;
/**
 * Checks if the given value is primitive.
 *
 * Primitive Types: number , string , boolean , symbol, bigint, undefined, null
 *
 * @param {*} value value to check
 * @returns {boolean} result
 */
declare const isPrimitive: (value: any) => boolean;
declare const isFunction: (value: any) => value is Function;
declare const isString: (value: any) => value is string;
declare const isInt: (value: any) => value is number;
declare const isFloat: (value: any) => value is number;
declare const isNumber: (value: any) => value is number;
declare const isDate: (value: any) => value is Date;
declare const isEmpty: (value: any) => boolean;
declare const isEqual: <TType>(x: TType, y: TType) => boolean;

export { AggregateError, alphabetical, boil, callable, camel as camal, camel, capitalize, chain, clone, cluster, compose, counting, dash, debounce, defer, diff, draw, first, flat, fork, get, group, intersects, invert, isArray, isDate, isEmpty, isEqual, isFloat, isFunction, isInt, isNumber, isObject, isPrimitive, isString, isSymbol, iterate, last, list, listify, lowerize, map, mapEntries, mapKeys, mapValues, max, memo, merge, min, objectify, omit, parallel, partial, partob, pascal, pick, proxied, random, range, reduce, replace, replaceOrAppend, retry, select, series, shake, shift, shuffle, sift, sleep, snake, sort, sum, template, throttle, title, toFloat, toInt, toggle, trim, tryit as try, tryit, uid, unique, upperize, zip };
